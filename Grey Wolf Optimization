import numpy as np
import matplotlib.pyplot as plt

# SUPER SIMPLE GWO for Wind Turbine Placement
def simple_gwo():
    print("=== WIND TURBINE PLACEMENT OPTIMIZATION ===\n")
    
    # Problem: Find best position for maximum wind energy
    # We have 2 turbines to place in a 10km x 10km area
    # Wind comes mostly from northwest direction
    
    def wind_energy(x):
        """
        Calculate wind energy production
        x = [x1, y1, x2, y2] - positions of 2 turbines
        Higher return = better (more energy)
        """
        x1, y1, x2, y2 = x
        
        # Base wind pattern (wind stronger in northwest)
        wind_power_1 = 100 - 0.5 * abs(x1 - 2) - 0.3 * abs(y1 - 8)
        wind_power_2 = 100 - 0.5 * abs(x2 - 2) - 0.3 * abs(y2 - 8)
        
        # Penalty if turbines are too close (wake effect)
        distance = np.sqrt((x1-x2)**2 + (y1-y2)**2)
        if distance < 3:
            penalty = 100 * (3 - distance)
        else:
            penalty = 0
            
        total_energy = wind_power_1 + wind_power_2 - penalty
        
        # We want to MAXIMIZE energy, so return negative for minimization
        return -total_energy
    
    # Algorithm parameters
    num_wolves = 15
    max_iterations = 50
    num_dimensions = 4  # x1, y1, x2, y2
    
    # Search space: 10km x 10km area
    lower_bound = [0, 0, 0, 0]
    upper_bound = [10, 10, 10, 10]
    
    # Step 1: Initialize population randomly
    wolves = np.random.uniform(lower_bound, upper_bound, (num_wolves, num_dimensions))
    
    # Initialize alpha, beta, delta (best solutions)
    alpha_pos = np.zeros(num_dimensions)
    beta_pos = np.zeros(num_dimensions)
    delta_pos = np.zeros(num_dimensions)
    
    alpha_score = float('inf')  # We're minimizing the negative energy
    beta_score = float('inf')
    delta_score = float('inf')
    
    convergence = []  # To track progress
    
    print("Starting optimization...")
    print("Iteration | Best Energy")
    print("-" * 25)
    
    # Main optimization loop
    for iteration in range(max_iterations):
        # Step 2: Evaluate all wolves
        for i in range(num_wolves):
            fitness = wind_energy(wolves[i])
            
            # Update leaders
            if fitness < alpha_score:
                alpha_score = fitness
                alpha_pos = wolves[i].copy()
            elif fitness < beta_score:
                beta_score = fitness
                beta_pos = wolves[i].copy()
            elif fitness < delta_score:
                delta_score = fitness
                delta_pos = wolves[i].copy()
        
        # Step 3: Update parameter 'a' (decreases from 2 to 0)
        a = 2 - iteration * (2 / max_iterations)
        
        # Step 4: Update all wolves' positions
        for i in range(num_wolves):
            for j in range(num_dimensions):
                # Calculate coefficients for alpha
                r1, r2 = np.random.random(), np.random.random()
                A1 = 2 * a * r1 - a
                C1 = 2 * r2
                D_alpha = abs(C1 * alpha_pos[j] - wolves[i, j])
                X1 = alpha_pos[j] - A1 * D_alpha
                
                # Calculate coefficients for beta
                r1, r2 = np.random.random(), np.random.random()
                A2 = 2 * a * r1 - a
                C2 = 2 * r2
                D_beta = abs(C2 * beta_pos[j] - wolves[i, j])
                X2 = beta_pos[j] - A2 * D_beta
                
                # Calculate coefficients for delta
                r1, r2 = np.random.random(), np.random.random()
                A3 = 2 * a * r1 - a
                C3 = 2 * r2
                D_delta = abs(C3 * delta_pos[j] - wolves[i, j])
                X3 = delta_pos[j] - A3 * D_delta
                
                # Update position (average of all three)
                wolves[i, j] = (X1 + X2 + X3) / 3
            
            # Step 5: Apply boundary constraints
            for j in range(num_dimensions):
                if wolves[i, j] < lower_bound[j]:
                    wolves[i, j] = lower_bound[j]
                if wolves[i, j] > upper_bound[j]:
                    wolves[i, j] = upper_bound[j]
        
        # Store convergence
        convergence.append(-alpha_score)  # Convert back to positive energy
        
        # Print progress
        if (iteration + 1) % 10 == 0:
            print(f"{iteration + 1:9d} | {-alpha_score:11.2f} kWh")
    
    # Results
    print("\n" + "=" * 50)
    print("OPTIMIZATION COMPLETE!")
    print("=" * 50)
    print(f"Maximum Energy Production: {-alpha_score:.2f} kWh")
    print(f"\nOptimal Turbine Positions:")
    print(f"Turbine 1: ({alpha_pos[0]:.2f} km, {alpha_pos[1]:.2f} km)")
    print(f"Turbine 2: ({alpha_pos[2]:.2f} km, {alpha_pos[3]:.2f} km)")
    
    # Calculate distance between turbines
    distance = np.sqrt((alpha_pos[0]-alpha_pos[2])**2 + (alpha_pos[1]-alpha_pos[3])**2)
    print(f"Distance between turbines: {distance:.2f} km")
    
    # Plot results
    plt.figure(figsize=(15, 5))
    
    # Plot 1: Convergence
    plt.subplot(1, 3, 1)
    plt.plot(convergence, 'b-', linewidth=2)
    plt.title('GWO Convergence')
    plt.xlabel('Iteration')
    plt.ylabel('Energy Production (kWh)')
    plt.grid(True)
    
    # Plot 2: Wind field
    plt.subplot(1, 3, 2)
    x = np.linspace(0, 10, 20)
    y = np.linspace(0, 10, 20)
    X, Y = np.meshgrid(x, y)
    Z = 100 - 0.5 * abs(X - 2) - 0.3 * abs(Y - 8)
    
    plt.contourf(X, Y, Z, levels=20, cmap='Blues')
    plt.colorbar(label='Wind Power')
    plt.title('Wind Power Distribution')
    plt.xlabel('X (km)')
    plt.ylabel('Y (km)')
    
    # Plot 3: Final turbine positions
    plt.subplot(1, 3, 3)
    plt.scatter(alpha_pos[0], alpha_pos[1], c='red', s=200, label='Turbine 1', marker='^')
    plt.scatter(alpha_pos[2], alpha_pos[3], c='blue', s=200, label='Turbine 2', marker='^')
    plt.xlim(0, 10)
    plt.ylim(0, 10)
    plt.title('Optimal Turbine Placement')
    plt.xlabel('X (km)')
    plt.ylabel('Y (km)')
    plt.grid(True)
    plt.legend()
    
    plt.tight_layout()
    plt.show()
    
    return alpha_pos, -alpha_score

# Run the optimization
if __name__ == "__main__":
    best_solution, best_energy = simple_gwo()
