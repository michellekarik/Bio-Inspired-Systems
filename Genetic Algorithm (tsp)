import random
import math

def tsp_genetic_algorithm():
    """
    Real-world example: Traveling Salesman Problem using Genetic Algorithm
    
    Problem: A salesman needs to visit 8 cities and return home.
    Goal: Find the shortest route that visits all cities exactly once.
    """
    
    # Real city coordinates (simplified - could be GPS coordinates)
    cities = {
        'New York': (0, 0),
        'Boston': (2, 3),
        'Philadelphia': (1, -1),
        'Washington': (2, -3),
        'Chicago': (-3, 1),
        'Detroit': (-2, 3),
        'Miami': (4, -5),
        'Atlanta': (3, -2)
    }
    
    city_names = list(cities.keys())
    num_cities = len(city_names)
    
    # Parameters
    POPULATION_SIZE = 50
    GENERATIONS = 100
    CROSSOVER_RATE = 0.8
    MUTATION_RATE = 0.2
    
    print("=== TRAVELING SALESMAN PROBLEM ===")
    print(f"Cities to visit: {city_names}")
    print(f"Population: {POPULATION_SIZE}, Generations: {GENERATIONS}")
    print("-" * 50)
    
    # Step 1: Initialize Population
    def create_route():
        """Create a random route (permutation of cities)"""
        route = list(range(num_cities))  # [0,1,2,3,4,5,6,7] representing cities
        random.shuffle(route)
        return route
    
    population = [create_route() for _ in range(POPULATION_SIZE)]
    
    # Step 2: Fitness Function
    def calculate_distance(city1_idx, city2_idx):
        """Calculate Euclidean distance between two cities"""
        x1, y1 = cities[city_names[city1_idx]]
        x2, y2 = cities[city_names[city2_idx]]
        return math.sqrt((x2-x1)**2 + (y2-y1)**2)
    
    def fitness(route):
        """Calculate total route distance (lower is better, so we return negative)"""
        total_distance = 0
        for i in range(len(route)):
            from_city = route[i]
            to_city = route[(i + 1) % len(route)]  # Return to start city
            total_distance += calculate_distance(from_city, to_city)
        
        # Return negative distance (GA maximizes fitness, we want to minimize distance)
        return -total_distance
    
    # Step 3: Selection (Tournament)
    def tournament_selection(pop, fitness_scores):
        """Select parent using tournament selection"""
        tournament_size = 3
        tournament_indices = random.sample(range(len(pop)), tournament_size)
        tournament_fitness = [fitness_scores[i] for i in tournament_indices]
        winner_idx = tournament_indices[tournament_fitness.index(max(tournament_fitness))]
        return pop[winner_idx][:]
    
    # Step 4: Crossover (Order Crossover - specific for TSP)
    def order_crossover(parent1, parent2):
        """Order crossover preserves the relative order of cities"""
        if random.random() > CROSSOVER_RATE:
            return parent1[:], parent2[:]
        
        size = len(parent1)
        start, end = sorted(random.sample(range(size), 2))
        
        # Create children
        child1 = [-1] * size
        child2 = [-1] * size
        
        # Copy the segment
        child1[start:end] = parent1[start:end]
        child2[start:end] = parent2[start:end]
        
        # Fill remaining positions
        def fill_child(child, parent):
            remaining = [item for item in parent if item not in child]
            for i in range(size):
                if child[i] == -1:
                    child[i] = remaining.pop(0)
        
        fill_child(child1, parent2)
        fill_child(child2, parent1)
        
        return child1, child2
    
    # Step 5: Mutation (Swap Mutation)
    def swap_mutation(route):
        """Randomly swap two cities in the route"""
        mutated = route[:]
        if random.random() < MUTATION_RATE:
            i, j = random.sample(range(len(mutated)), 2)
            mutated[i], mutated[j] = mutated[j], mutated[i]
        return mutated
    
    # Helper function to display route
    def display_route(route, distance):
        """Display the route with city names and total distance"""
        route_names = [city_names[i] for i in route]
        route_str = " → ".join(route_names) + f" → {route_names[0]}"
        print(f"Route: {route_str}")
        print(f"Total Distance: {distance:.2f}")
        return route_str
    
    # Main Evolution Loop
    best_ever_fitness = float('-inf')
    best_ever_route = None
    
    for generation in range(GENERATIONS):
        # Calculate fitness for all routes
        fitness_scores = [fitness(route) for route in population]
        
        # Track best solution
        best_idx = fitness_scores.index(max(fitness_scores))
        best_route = population[best_idx]
        best_fitness = fitness_scores[best_idx]
        best_distance = -best_fitness  # Convert back to positive distance
        
        # Update all-time best
        if best_fitness > best_ever_fitness:
            best_ever_fitness = best_fitness
            best_ever_route = best_route[:]
        
        # Print progress every 10 generations
        if generation % 10 == 0 or generation == GENERATIONS - 1:
            print(f"Generation {generation}: Best Distance = {best_distance:.2f}")
        
        # Create next generation
        new_population = []
        
        # Keep best route (elitism)
        new_population.append(best_route[:])
        
        # Generate rest of population
        while len(new_population) < POPULATION_SIZE:
            # Select parents
            parent1 = tournament_selection(population, fitness_scores)
            parent2 = tournament_selection(population, fitness_scores)
            
            # Crossover
            child1, child2 = order_crossover(parent1, parent2)
            
            # Mutate
            child1 = swap_mutation(child1)
            child2 = swap_mutation(child2)
            
            new_population.extend([child1, child2])
        
        population = new_population[:POPULATION_SIZE]
    
    # Final Results
    print("\n" + "="*50)
    print("FINAL BEST SOLUTION:")
    print("="*50)
    final_distance = -best_ever_fitness
    display_route(best_ever_route, final_distance)
    
    # Show improvement
    random_route = create_route()
    random_distance = -fitness(random_route)
    improvement = ((random_distance - final_distance) / random_distance) * 100
    
    print(f"\nRandom route distance: {random_distance:.2f}")
    print(f"GA optimized distance: {final_distance:.2f}")
    print(f"Improvement: {improvement:.1f}% better!")
    
    return best_ever_route, final_distance

# Additional: Visualization helper
def analyze_solution():
    """Run the GA and show detailed analysis"""
    print("Starting Traveling Salesman Problem optimization...")
    print("This could be used for:")
    print("• Delivery truck routes")
    print("• Manufacturing machine scheduling") 
    print("• Tourist itinerary planning")
    print("• Circuit board drilling sequences\n")
    
    best_route, best_distance = tsp_genetic_algorithm()
    
    print(f"\nThis solution saves time and fuel costs!")
    print(f"In a real scenario with 100+ cities, savings could be thousands of dollars.")
    
    return best_route, best_distance

# Run the example
if __name__ == "__main__":
    analyze_solution()
